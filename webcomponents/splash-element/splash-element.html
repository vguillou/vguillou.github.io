<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-meta/core-meta.html">
<link rel="import" href="../core-transition/core-transition-css.html">

<!--
Simple element allowing to display a splash while web components are getting
polyfilled and your main web component is getting fully ready. Then plays
a sleek and customizable transition from your splash to your web component.
The splash needs to be standard HTML5 and MUST have the 'splash' class
and your main web component MUST have the 'element' class.

They can both specify what transition effect should be applied via
a 'transition' attribute, having one of these (self-explanatory) values :
'core-transition-fade', 'core-transition-center', 'core-transition-top',
'core-transition-bottom', 'core-transition-left' or 'core-transition-right'
(default is 'core-transition-fade'). See <core-transition> for more information.

After the transition is played, this element fires a 'transitionend' event.

Usage :
	<style>
		.splash {
			position: absolute;
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 0;
			background-repeat: no-repeat;
			background-position: 50%;
			background-size: 224px;
			background-image: url(res/logo.svg);
			background-color: #eee;
		}
	</style>
	
	<splash-element minSplashDuration="2000" fit>
		<div class="splash" transition="core-transition-center"></div>
		<your-element class="element" transition="core-transition-bottom" fit></your-element>
	</splash-element>

Note : Do not use Polymer's 'unresolved' attribute on the
splash-element or any of it's parents (including the body).
-->
<polymer-element name="splash-element">
	<template>
		<div id="splashContainer" fit>
			<content select=".splash"></content>
		</div>
		<div id="elementContainer" style="display: none;" fit>
			<content select=".element"></content>
		</div>
	</template>
	<script>
		Polymer('splash-element', {
			publish: {
				/**
				 * The minimum splash duration in milliseconds.
				 * Note that this attribute will be ignored
				 * if the 'waitFor' attribute is set.
				 * 
				 * @attribute minSplashDuration
				 * @type number
				 * @default 0
				 */
				minSplashDuration: {value: 0, reflect: false},
				
				/**
				 * If set, the transition wont be played until the inner
				 * element (with and 'element' id) fires an event of this
				 * given name.
				 * Note that setting this attribute overrides the 'minSplashDuration'
				 * attribute, and therefore the transition will never play
				 * if the inner element doesn't fire the given event.
				 * 
				 * @attribute waitFor
				 * @type string
				 * @default null
				 */
				waitFor: {value: null, reflect: false},
				
				/**
				 * If true, the splash and transition sequence must be initiated
				 * manually by calling the 'go' method.
				 *
				 * @attribute manual
				 * @type boolean
				 * @default false
				 */
				manual: {value: false, reflect: false}
			},
			
			initTimestamp: Date.now(),

			splashTransition: null,

			elementTransition: null,
			
			intialized: false,
			
			played: false,

			defaultTransitionType: 'core-transition-fade',
			
			/**
			 * Triggers the transition sequence.
			 * The actual effect will not that place before
			 * the 'minSplashDuration' milliseconds, or will
			 * wait for the event 'waitFor', depending on how you
			 * set up this component.
			 *
			 * @method initiate
			 */
			initiate: function() {
				this.initTimestamp = Date.now();
				var element = this.querySelector('.element');
				this.checkIfShouldPlay(element);
			},
			
			/**
			 * Rewinds the transition immediately,
			 * ie plays it backward.
			 *
			 * @method rewind
			 */
			rewind: function() {
				if (this.played)
					this.playTransition(0, false);
			},
			
			domReady: function() {
				var elementContainer = this.$.elementContainer;
				var splash = this.querySelector('.splash');
				var element = this.querySelector('.element');
			    var splType = splash && splash.hasAttribute('transition') ? splash.getAttribute('transition') : this.defaultTransitionType;
			    var elmType = element && element.hasAttribute('transition') ? element.getAttribute('transition') : this.defaultTransitionType;
				
			    var meta = document.createElement('core-meta');
			    meta.type = 'transition';
			    this.splashTransition = meta.byId(splType);
			    this.elementTransition = meta.byId(elmType);
				
				if (this.elementTransition) {
					// Setup plays the transition once, so we can
					// play it backwards after ('out' effect for
					// the splash, 'in' for the element)
					this.elementTransition.setup(elementContainer);
				}
				
				this.addEventListener('core-transitionend', this.end.bind(this));
				if (!this.manual) {
					this.checkIfShouldPlay(element);
				}
			},
			
			checkIfShouldPlay: function(element) {
				if (element && this.waitFor)
					element.addEventListener(this.waitFor, this.waitForHandler.bind(this));
				
				if (!this.waitFor) {
					var delta = Math.max(this.initTimestamp - Date.now() + this.minSplashDuration, 0);
					this.playTransition(delta, true);
				}
			},
			
			waitForHandler: function(e) {
				this.playTransition(0, true);
			},
			
			playTransition: function(delay, forward) {
				var splashContainer = this.$.splashContainer;
				var elementContainer = this.$.elementContainer;
				
				this.changeDisplay(splashContainer, 'block');
				this.changeDisplay(elementContainer, 'block');
				
				var element = this.querySelector('.element');
				if (element)
					element.removeEventListener(this.waitFor, this.waitForHandler);
				
				this.async(function() {
					if (this.splashTransition) {
						if (!this.intialized) {
							this.splashTransition.setup(splashContainer);
						}
						this.splashTransition.go(splashContainer, {opened: !forward});
					}
					if (this.elementTransition) {
						this.elementTransition.go(elementContainer, {opened: forward});
					}
					this.played = forward;
					this.intialized = true;
				}, null, delay);
			},
			
			end: function(e) {
				this.async(function() {
					this.changeDisplay(this.$.splashContainer, this.played ? 'none' : 'block');
					this.changeDisplay(this.$.elementContainer, this.played ? 'block' : 'none');
					this.fire('transitionend', null, this, false);
				}, null, 50);
			},
			
			changeDisplay: function(target, newValue) {
				if (target && target.style)
					target.style.display = newValue ? newValue : '';
			}
		});
	</script>
</polymer-element>