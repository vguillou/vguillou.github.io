<link rel="import" href="../polymer/polymer.html">

<!--
A Material design multi-progress bar, inspired by Google Fit.

Add nodes (typically divs) in the element light DOM with the `bar` CSS class
and a decimal `data-value` attribute to add progress bars.

Note that these bars have a rtl (right to left) layout by default, in order to end-justify its
children (Google Fit style).

Example:

    <material-progress-bars max="128" bar-height="22" legend-label="My legend:">
      <div class="bar" data-value="21" data-legend="Walk">
        <iron-icon icon="maps:directions-walk"></iron-icon>
      </div>
      <div class="bar" data-value="13" data-legend="Run">
        <iron-icon icon="maps:directions-run"></iron-icon>
      </div>
      <div class="bar" data-value="50" data-legend="Hello">
        <iron-icon icon="maps:directions-bike"></iron-icon>
        <span>Hello</span>
      </div>
      <div class="bar" data-value="30" data-legend="World">
        <span>World</span>
      </div>
    </material-progress-bars>

### Children bars API

The direct children of a &lt;material-progress-bars&gt; element represent the different bars to display.

The following attributes are available to control their behavior:

Attribute | Description | Default
----------------|-------------|----------
`data-value` | The required value represented by the bar. Must not be `undefined` or `0` for the bar to be displayed. | `undefined`
`data-legend` | An optional `String` to be displayed in the legend. | `undefined`


### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--material-progress-bar-background-color` | Background color of the whole progress bar. | `#E0E0E0`
`--material-progress-bars-style` | Mixin applied to the progress bar container. | `{}`
`--material-progress-bars-legend-style` | Mixin applied to the legend. | `{}`

@group material-progress
@element material-progress-bar
@demo demo/index.html
-->
<dom-module id="material-progress-bars">
  <template>
    <style>
      :host {
        @apply(--layout-vertical);
      }
      #barsContainer {
        @apply(--layout);
        overflow: hidden;
        -webkit-transform: translateZ(0);
        -moz-transform: translateZ(0);
        -ms-transform: translateZ(0);
        -o-transform: translateZ(0);
        transform: translateZ(0);
        background-color: var(--material-progress-bar-background-color, #E0E0E0);
        border-radius: calc(var(--material-progress-bar-height) / 2);
        min-width: var(--material-progress-bar-height);
        @apply(--material-progress-bars-style);
      }
      #barsContainer,
      :host > #barsContainer > ::content > * {
        height: var(--material-progress-bar-height);
      }
      :host > #barsContainer > ::content > * {
        @apply(--layout-inline);
        @apply(--layout-horizontal-reverse);
        @apply(--layout-center);
        float: left;
        position: relative;
        margin-left: calc(-var(--material-progress-bar-height) / 2);
        border-radius: 0 calc(var(--material-progress-bar-height) / 2) calc(var(--material-progress-bar-height) / 2) 0;
        width: 0px;
        z-index: 0;
      }
      :host([animated]) > #barsContainer > ::content > * {
        -webkit-transition: width 850ms cubic-bezier(0.4, 0.0, 0.2, 1), z-index 0ms 850ms;
        -ms-transition: width 850ms cubic-bezier(0.4, 0.0, 0.2, 1), z-index 0ms 850ms;
        -moz-transition: width 850ms cubic-bezier(0.4, 0.0, 0.2, 1), z-index 0ms 850ms;
        -o-transition: width 850ms cubic-bezier(0.4, 0.0, 0.2, 1), z-index 0ms 850ms;
        transition: width 850ms cubic-bezier(0.4, 0.0, 0.2, 1), z-index 0ms 850ms;
      }
      :host([animated]) > #barsContainer > ::content > .entry {
        -webkit-transition: width 850ms cubic-bezier(0.4, 0.0, 0.2, 1);
        -ms-transition: width 850ms cubic-bezier(0.4, 0.0, 0.2, 1);
        -moz-transition: width 850ms cubic-bezier(0.4, 0.0, 0.2, 1);
        -o-transition: width 850ms cubic-bezier(0.4, 0.0, 0.2, 1);
        transition: width 850ms cubic-bezier(0.4, 0.0, 0.2, 1);
      }
      :host > #barsContainer > ::content > * > * {
        float: right;
        color: #FFFFFF;
      }
      :host([animated]) > #barsContainer > ::content > * > * {
        opacity: 0;
      }
      :host([animated]) > #barsContainer > ::content > :not(.entry) > * {
        opacity: 1;
        -webkit-transition: opacity 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
        -ms-transition: opacity 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
        -moz-transition: opacity 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
        -o-transition: opacity 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
        transition: opacity 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
      }
      :host > #barsContainer > ::content > * > iron-icon {
        height: calc(var(--material-progress-bar-height) * 2/3 - 1px);
        width: calc(var(--material-progress-bar-height) * 2/3);
        margin-right: calc(var(--material-progress-bar-height) * 1/6);
      }
      :host > #barsContainer > ::content > * > span {
        margin: 0 calc(var(--material-progress-bar-height) * 1/3) 0 calc(var(--material-progress-bar-height) * 5/6);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      :host > .legend {
        margin-top: 4px;
        @apply(--material-progress-bars-legend-style);
      }
      :host > .legend > span {
        margin: 0 8px;
      }
    </style>
    <div id="barsContainer">
      <content id="content" selector=".bar[data-value]"></content>
    </div>
    <div class="legend" hidden$="[[_computeShowLegend(_legendItems)]]">
      <template is="dom-repeat" items="[[_legendItems]]" as="l">
        <span style$="color: [[l.color]];">[[l.label]]</span>
      </template>
    </div>
  </template>
  <script>
  (function() {
    'use strict';
    Polymer({
      is: 'material-progress-bars',
      properties: {
        /**
         * Maximum value represented by all progress bars.
         * Bars will be scaled according to their `data-value` attribute
         * and this maximum.
         */
        max: {
          type: Number,
          value: 100,
          observer: '_refresh'
        },
        /**
         * Sum of all the values of the bars.
         *
         * @type {Number}
         */
        sum: {
          type: Number,
          value: 0,
          notify: true,
          readOnly: true,
          reflectToAttribute: true
        },
        /**
         * Height of the bar and bars, in pixels.
         */
        barHeight: {
          type: Number,
          value: 22,
          observer: '_refresh'
        },
        /**
         * Animate when the size of a bar changes.
         */
        animated: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        /**
         * Label to display before the legend.
         */
        legendLabel: {
          type: String,
          value: '',
          observer: '_refresh'
        },
        /**
         * Array of the displayed bar nodes (ie direct children with 
         * the `bar` class and a `data-value` attribute).
         * 
         * @type {Array}
         */
        bars: {
          type: Array,
          notify: true,
          readOnly: true
        }
      },
      /**
       * Refresh the element.
       */
      refresh: function() {
        if (this._attached) {
          var realMax = Math.max(this._computeSumAndBars(), this.max),
          barMeta, i = 0, animationDelay = 600 / (this.bars.length - 1);

          // Legend initialization
          if (!this._legendItems) {
            this._legendItems = [];
          } else {
            this.splice('_legendItems', 0, this._legendItems.length);
          }
          if (this.legendLabel) {
            this.push('_legendItems', {label: this.legendLabel});
          }

          // Computing each bar
          if (this.bars) {
            this.bars.forEach(function(bar, index) {
              barMeta = this._getBarMeta(bar);
              // Sizing/Styling
              this.toggleClass('visible', barMeta.value > 0, bar);
              bar.style.width = this.bars.length > 0 ? this._getWidthForValue(barMeta.value, realMax) : '0px';
              bar.style.zIndex = this.bars.length + 1 - index;

              if (barMeta.value > 0) {
                // Entry animation
                if (!this._initialized) {
                  this._playFirstAnimation(bar, i, animationDelay);
                }
                // Legend
                if (barMeta.legend) {
                  this.push('_legendItems', {label: barMeta.legend, color: window.getComputedStyle(bar).backgroundColor});
                }
                i++;
              }
            }, this);
          }
          // Update Polymer's custom styles
          if (!this._oldBarHeight || this._oldBarHeight !== this.barHeight) {
            this.customStyle['--material-progress-bar-height'] = this.barHeight + 'px';
            this.updateStyles();
            this._oldBarHeight = this.barHeight;
          }
          this._initialized = true;
        }
      },
      ready: function() {
        this._mutationObserver = new MutationObserver(this._observeChildrenMutations.bind(this));
        this._mutationObserver.observe(this, {childList: true, attributes: true, subtree: true});
      },
      attached: function() {
        this._attached = true;
        this._refresh();
      },
      detached: function() {
        if (this._mutationObserver) {
          this._mutationObserver.disconnect();
          this._mutationObserver = null;
        }
      },
      _refresh: function() {
        this.debounce('refresh', this.refresh, 10);
      },
      _computeSumAndBars: function() {
        var sum = 0, validBars = [],
        allChildren = (Polymer.dom(this.$.content).getDistributedNodes());
        if (allChildren) {
          allChildren.forEach(function(child) {
            if (child.classList && child.classList.contains('bar') && child.hasAttribute('data-value')) {
              validBars.push(child);
              sum += this._getBarMeta(child).value;
            }
          }, this);
        }
        this._setBars(validBars);
        this._setSum(sum);
        return sum;
      },
      _getBarMeta: function(bar) {
        var meta = {value: 0, legend: undefined}, val;
        if (bar && bar.getAttribute) {
          val = Number(bar.getAttribute('data-value'));
          meta.value = isNaN(val) ? 0 : Math.max(0, val);
          meta.legend = bar.getAttribute('data-legend');
        }
        return meta;
      },
      _getWidthForValue: function(value, max) {
        var width = (max > 0 ? (Math.floor(value / max * 10000) / 100) : '0') + '%',
        negativeMargin = this.barHeight / 2;
        return 'calc(' + width + ' + ' + negativeMargin + 'px' + ')';
      },
      _playFirstAnimation: function(node, index, animationDelay) {
        this.toggleClass('entry', true, node);
        (function(node, index, animationDelay) {
          this.async(function() {
            this.toggleClass('entry', false, node);
          }, 500 + animationDelay * index);
        }.bind(this))(node, index, animationDelay);
      },
      _computeShowLegend: function(legendItems) {
        return legendItems && legendItems.length > 0;
      },
      _observeChildrenMutations: function(mutations) {
        var t, relevantMut = false;
        var needsUpdate = mutations.some(function (m) {
          t = m.target;
          relevantMut = m.type === 'attributes' && t && (t.parentElement === this || t.parentElement === this.$.barsContainer) && (m.attributeName === 'data-value' || m.attributeName === 'data-legend');
          relevantMut = relevantMut || (m.type === 'childList' && (t === this || t === this.$.barsContainer));
          return relevantMut;
        }, this);
        if (needsUpdate) {
          this._refresh();
        }
      }
    });
  })();
  </script>
</dom-module>